/**
 * This is the controller class for handling HTTP requests related to Check Out operations. Checkout information is
 * stored and retrieved via HTTP sessions. Authentication is required when operating on checkout related processes.
 * <p>
 * Endpoints:
 * GET /api/checkout/api/checkout: Get Checkout information of authenticated reader.
 * PUT /api/checkout/update/shipping: Update shipping type of checkout.
 * PUT /api/checkout/update/payment: Update payment type of checkout.
 * POST /api/checkout/place_order: Place an Order.
 *
 * @author Tong
 * @see AuthUtil
 * @see PredefinedRole
 */

package book.demo.java.controller;

import book.demo.java.entity.account.external.Reader;
import book.demo.java.entity.cart.CartItem;
import book.demo.java.entity.cart.Checkout;
import book.demo.java.entity.cart.PaymentType;
import book.demo.java.entity.cart.ShippingType;
import book.demo.java.entity.order.Order;
import book.demo.java.service.*;
import book.demo.java.util.AuthUtil;
import book.demo.java.util.EmailDetails;
import book.demo.java.util.PredefinedRole;
import io.swagger.v3.oas.annotations.Operation;
import org.apache.shiro.authz.UnauthenticatedException;
import org.apache.shiro.authz.annotation.RequiresRoles;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpSession;
import java.util.List;
import java.util.NoSuchElementException;

@RestController
@RequestMapping("/api/checkout")
public class CheckoutController {

    // HTTP session attribute name for storing checkout information
    private final String CHECKOUT_SESSION_ATTR = "checkout";

    @Autowired
    private CheckoutService checkoutService;

    @Autowired
    private CartItemService cartItemService;

    @Autowired
    private OrderService orderService;

    @Autowired
    private EmailService emailService;

    @Autowired
    private ReaderService readerService;

    /**
     * After authenticating the current logged in subject is a Reader, it retrieves the checkout information stored in
     * current HTTP session. If there is no Checkout object stored in the current session or that the session is new,
     * then Checkout information would be generated by CartItems stored in database.
     *
     * @param session the current HTTP session.
     * @return A ResponseEntity containing a Checkout object and an HTTP status code.
     */
    @Operation(summary = "Get Checkout information of logged in reader.")
    @GetMapping
    @RequiresRoles(PredefinedRole.READER_ROLE)
    public ResponseEntity<Checkout> getCheckoutInfo(HttpSession session) {

        String username = AuthUtil.getAuthenticatedUsername();

        List<CartItem> cartItems = cartItemService.getCartItemsByReaderUsername(username);
        if (cartItems.isEmpty()) return new ResponseEntity<>(HttpStatus.NO_CONTENT);

        Checkout checkout = (Checkout) session.getAttribute(CHECKOUT_SESSION_ATTR);

        // if session is not new, but still no checkout info
        if (session.isNew() || checkout == null) {
            setSessionMaxInactiveInterval(session);
            checkout = checkoutService.getCheckout(cartItems);
            session.setAttribute(CHECKOUT_SESSION_ATTR, checkout);
        }

        // if Checkout is null, an exception would have been thrown in the helper method for retrieving checkout
        if (checkout == null) {
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        }

        return new ResponseEntity<>(checkout, HttpStatus.OK);
    }

    /**
     * The authenticated reader sends in HTTP request to update the shipping type in checkout information.
     *
     * @param session      the current HTTP session.
     * @param shippingType The updated shippingType.
     * @return A ResponseEntity containing the updated Checkout object and an HTTP status code.
     */
    @Operation(summary = "Update shipping type of checkout.")
    @PutMapping("/update/shipping")
    @RequiresRoles(PredefinedRole.READER_ROLE)
    public ResponseEntity<Checkout> updateShippingType(HttpSession session, @RequestParam ShippingType shippingType) {
        Checkout checkout = retrieveCheckoutFromSession(session);
        checkoutService.updateShippingType(checkout, shippingType);
        session.setAttribute(CHECKOUT_SESSION_ATTR, checkout);
        return new ResponseEntity<>(checkout, HttpStatus.OK);
    }

    /**
     * The authenticated reader sends in HTTP request to update the payment type in checkout information.
     *
     * @param session     the current HTTP session.
     * @param paymentType The updated paymentType.
     * @return A ResponseEntity containing the updated Checkout object and an HTTP status code.
     */
    @Operation(summary = "Update payment type of checkout.")
    @PutMapping("/update/payment")
    @RequiresRoles(PredefinedRole.READER_ROLE)
    public ResponseEntity<Checkout> updatePaymentType(HttpSession session, @RequestParam PaymentType paymentType) {
        Checkout checkout = retrieveCheckoutFromSession(session);
        checkoutService.updatePaymentType(checkout, paymentType);
        session.setAttribute(CHECKOUT_SESSION_ATTR, checkout);
        return new ResponseEntity<>(checkout, HttpStatus.OK);
    }

    /**
     * The authenticated Reader places an order by using the latest Checkout information. Once the Order is placed
     * and saved, an email containing order information would be sent to Reader.
     *
     * @param session the current HTTP session.
     * @return the Order object containing information about the order that has been placed and an HTTP status code.
     */
    @Operation(summary = "Place an Order.")
    @PostMapping("/place_order")
    @RequiresRoles(PredefinedRole.READER_ROLE)
    public ResponseEntity<Order> saveOrder(HttpSession session) {
        String username = AuthUtil.getAuthenticatedUsername();
        Reader reader = readerService.findReaderByUsername(username);

        Checkout checkout = retrieveCheckoutFromSession(session);
        Order order = orderService.createOrder(reader, checkout);
        EmailDetails emailDetails = new EmailDetails(reader.getEmail(), "Order successfully created.",
                "Order id: " + order.getId() + ".");
        emailService.sendSimpleMail(emailDetails);
        session.removeAttribute(CHECKOUT_SESSION_ATTR);
        return new ResponseEntity<>(order, HttpStatus.CREATED);
    }

    /**
     * Sets the maximum inactive interval for an HTTP session.
     *
     * @param session the current HTTP session.
     */
    private void setSessionMaxInactiveInterval(HttpSession session) {
        // A session will expire if it has been inactive for 15 minutes.
        int SESSION_MAX_INACTIVE_INTERVAL = 60 * 15;
        session.setMaxInactiveInterval(SESSION_MAX_INACTIVE_INTERVAL);
    }

    /**
     * Helper method for checking session expiration and then retrieving the checkout from the current HTTP session.
     *
     * @return Checkout object retrieved from HTTP session.
     * @throws UnauthenticatedException if current session is new, meaning that the (previous) session containing
     *                                  checkout information has expired and therefore needs a new session.
     * @throws NoSuchElementException   if shopping cart is empty and no checkout would be generated.
     */
    private Checkout retrieveCheckoutFromSession(HttpSession session) {
        if (session.isNew()) {
            throw new UnauthenticatedException("Previous session has expired. Please checkout again.");
        }
        Checkout checkout = (Checkout) session.getAttribute(CHECKOUT_SESSION_ATTR);
        if (checkout == null) {
            throw new NoSuchElementException("Your shopping cart is empty. " +
                    "Please add items to your cart and checkout again.");
        }
        return checkout;
    }
}
